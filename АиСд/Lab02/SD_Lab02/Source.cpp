#include <iostream>
#include <stack> // стек
#include <queue> // очередь
#include <list>  // список
#include <cstdlib>


using namespace std;
int main()
{
    setlocale(LC_ALL, "rus");
    stack<int> Stack;
    queue<int> Queue;

    // матрица смежности
    int mas[10][10] = { { 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 }, 
    { 1, 0, 0, 0, 0, 0, 1, 1, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
    { 0, 0, 0, 0, 0, 1, 0, 0, 1, 0},
    { 1, 0, 0, 0, 0, 1, 0, 0, 0, 0 },
    { 0, 0, 0, 1, 1, 0, 0, 0, 1, 0 },
    { 0, 1, 0, 0, 0, 0, 0, 1, 0, 0 },
    { 0, 1, 1, 0, 0, 0, 1, 0, 0, 0 },
    { 0, 0, 0, 1, 0, 1, 0, 0, 0, 1 },
    { 0, 0, 0, 0, 0, 0, 0, 0, 1, 0 }, };

    // Список рёбер
    int listRibs[22][2] =
    { {1,2},{2,1},{1,5},{5,1},
        {2,7},{7,2},{2,8},{8,2},
        {7,8},{8,7},{8,3},{3,8},
        {5,6},{6,5},{6,4},{4,6},
        {6,9},{9,6},{4,9},{9,4},
        {9,10},{10,9} };

    // Список смежности
    int listSmezh[10][3] =
    {
        {2,5}, {1, 7, 8}, {8}, {6, 9}, {1, 6}, {4, 5, 9}, {2, 8}, {2, 3, 7}, {4, 6, 10 }, {9}
    };

    int num;
    cout << "Ведите каким способом обходить(1. в ширину 2. в глубину): ";
    cin >> num;
    cout << "\n";
    
    int nodes[10]; // вершины графа
    for (int i = 0; i < 10; i++)
        nodes[i] = 0; 

    switch (num)
    {
    case 1:
    {
        Queue.push(0); // помещаем в очередь первую вершину
        while (!Queue.empty())
        { // пока очередь не пуста
            int node = Queue.front(); // извлекаем вершину
            Queue.pop();
            nodes[node] = 2; // отмечаем ее как посещенную
            for (int j = 0; j < 10; j++)
            { // проверяем для нее все смежные вершины
                if (mas[node][j] == 1 && nodes[j] == 0)
                { // если вершина смежная и не обнаружена
                    Queue.push(j); // добавляем ее в очередь
                    nodes[j] = 1; // отмечаем вершину как обнаруженную
                }
            }
            cout << node + 1 << endl; // выводим номер вершины
        }
        break;
    }
    case 2:
    {
        Stack.push(0); // помещаем в очередь первую вершину
        while (!Stack.empty())
        { // пока стек не пуст
            int node = Stack.top(); // извлекаем вершину
            Stack.pop();
            if (nodes[node] == 2) continue;
            nodes[node] = 2; // отмечаем ее как посещенную
            for (int j = 9; j >= 0; j--)
            { // проверяем для нее все смежные вершины
                if (mas[node][j] == 1 && nodes[j] != 2)
                { // если вершина смежная и не обнаружена
                    Stack.push(j); // добавляем ее в cтек
                    nodes[j] = 1; // отмечаем вершину как обнаруженную
                }
            }
            cout << node + 1 << endl; // выводим номер вершины
        }
        break;
    }
    default:
        break;
    }

    system("pause");
    return 0;
}